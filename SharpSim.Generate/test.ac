arch arm;

regspace {
	bank RB (u32, 16, 4, 4, 0);
	slot PC (u32, 4, 60) PC;
	slot SP (u32, 4, 52) SP;
};

regspace {
	slot C (u8, 1, 0) C;
	slot Z (u8, 1, 1) Z;
	slot N (u8, 1, 2) N;
	slot V (u8, 1, 3) V;
	slot Q (u8, 1, 4);
};

regspace {
	bank FPSP (single, 32, 4, 4, 0);
	bank FPDP (double, 32, 8, 8, 0);

	vector VD (single, 2, 32, 4, 4, 0);
	vector VQ (single, 4, 16, 4, 4, 0);

	vector VU8 (u8, 8, 32, 1, 1, 0);
	vector VU16 (u16, 4, 32, 2, 2, 0);
	vector VU32 (u32, 2, 32, 4, 4, 0);

	bank VU64 (u64, 32, 8, 8, 0);
};

regspace {
	slot T (u8, 1, 0) ISA;
	slot M (u8, 1, 1);
	slot F (u8, 1, 2);
	slot I (u8, 1, 3);
	slot cpV (u8, 1, 4);

	slot SPSR (u32, 4, 8);
	slot DACR (u32, 4, 12);
	slot TTBR0 (u32, 4, 16);
	slot TTBR1 (u32, 4, 20);
	slot TTBCR (u32, 4, 24);
	slot DFSR (u32, 4, 28);
	slot IFSR (u32, 4, 32);
	slot DFAR (u32, 4, 36);
	slot IFAR (u32, 4, 40);

	slot CP_Status (u32, 4, 44);

	slot TPID (u32, 4, 48);
	slot CTXID (u32, 4, 52);
};

isa arm {
	format dpi1 {
		cond:4;
		op:3;
		func1:4;
		s:1;
		rn:4;
		rd:4;
		shift_amt:5;
		shift_type:2;
		subop1:1;
		rm:4;
	};

	format test {
		0x08:4;
	};
};

isa arm {
	instruction<dpi1> mov1 {
		match (op == 0 && subop1 == 0 && func1 == 0x0d && rn == 0);

		disasm {
			append "mov%[cond]%[sf] " ~ (cond, s);

			where (shift_amt == 0 && shift_type == 0) {
				append "%[reg], %[reg]" ~ (rd, rm);
			};
		};

		behaviour mov;
	};
};

behaviour<arm.dpi1> mov {
	u8 c;
	u32 imm32 = decode_imm(
		inst.shift_type,
		inst.shift_amt,
		read_register_bank(RB, inst.rm) + pc_check(inst.rm),
		c);

	write_register_bank(RB, inst.rd, imm32);

	if (inst.s) {
		if (inst.rd == 15) {
			return_from_exception();
		} else {
			__builtin_update_zn_flags(imm32);
			write_register(C, c);
		}
	}
};

behaviour<arm.dpi1> add {        
	u8 c;
	u32 imm32 = decode_imm(
		inst.shift_type,
		inst.shift_amt,
		read_register_bank(RB, inst.rm) + pc_check(inst.rm),
		c);

	u32 src1m = read_register_bank(RB, inst.rn) + pc_check(inst.rn);
	u32 result = add_with_flags(src1m, imm32, inst.s);

	write_register_bank(RB, inst.rd, result);
};

helper u32 pc_check(u8 idx) noinline
{
	return idx == 15 ? 8 : 0;
};

helper u32 decode_imm(u8 type, u8 shift, u32 bits, u8 &carry_out) {
	u8 carry_in = read_register(C);
	carry_out = carry_in;

	u32 val;
	switch(type) {
		case 0:	{
			val = lsli(bits, shift, carry_in, carry_out);
			break;
		} case 1: {
			val = lsri(bits, ((shift == 0) ? (u8)32 : (u8)shift), carry_in, carry_out);
			break;
		} case 2: {
			val = asri(bits, ((shift == 0) ? (u8)32 : (u8)shift), carry_in, carry_out);
			break;
		} case 3: {
			if (shift == 0) {
				val = rrxi(bits, carry_in, carry_out);
			} else {
				val = rori(bits, shift, carry_in, carry_out);
			}
			break;
		} default: {
			val = 0;
			break;
		}
	}

	return val;
};

helper u32 lsli(u32 bits, u8 shift, u8 carry_in, u8 &carry_out)
{
        carry_out = (shift == 0) ? carry_in : (u8)(bitsel(bits, (32 - shift)));
        return (u32) bits << shift;
};

helper u32 lsri(u32 bits, u8 shift, u8 carry_in, u8 &carry_out)
{
        u8 carry_shift = shift - 1;
        carry_out = shift ? (u8)((bits >> carry_shift) & 1) : (carry_in);

        return (shift == 32) ? (u32)0 : (u32)(bits >> shift);
};

helper u32 asri(u32 bits, u8 shift, u8 carry_in, u8 &carry_out)
{
        carry_out = (((s32)bits) >> (shift - 1)) & 1;

        shift = (shift == 32) ? 31 : shift;

        return ((s32) bits) >> shift;
};

helper u32 rrxi(u32 bits, u8 carry_in, u8 &carry_out)
{
        carry_out = (bits & 1);
        bits >>= 1;
        bits |= carry_in << (u32)31;
        return bits;
};

helper u32 rori(u32 bits, u8 shift, u8 carry_in, u8 &carry_out)
{
        shift &= 0x3f;

        u32 res = bits >>> shift;
        carry_out = ((res & 0x80000000) != 0);
        return res;
};

helper u32 bitsel(u32 val, u8 bit)
{
        return (val >> bit) & 1;
};

helper void return_from_exception()
{
};

helper u32 add_with_flags(u32 op1, u32 op2, bool set_flags)
{
        if (set_flags) {
                return __builtin_adc_flags(op1, op2, 0);
        } else {
                return op1 + op2;
        }
};